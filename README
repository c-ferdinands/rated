Rated is a fork of the RTG project (http://rtg.sourceforge.net/).
Specifically it's a fork of the rtgpoll daemon.

Rated is a high performance threaded SNMP poller written in C which
stores the time series data in a SQL database. It uses the net-snmp
library (http://www.net-snmp.org/) for retrieving the SNMP data and
has a modular backend for connecting to various databases. At the
moment it has drivers for MySQL, PostgreSQL and Oracle (experimental).

NOTE: currently only the postgres driver compiles. You may have to run
configure with the --without-mysql argument.

The database drivers are implemented as shared libraries and are loaded
as needed on startup. See the file DBI.TXT for details.

Rated uses SNMP get-next calls to poll its targets. This is similar to
net-snmp's snmpwalk or the bulk retrieval method outlined in RFC 1187.
This is different from mrtg/rtg which use the get operation. This has
been done to reduce the size of the target configuration and to
eliminate the need for a separate configuration generator (ie
cfgmaker/targetmaker). For a given target in the configuration it will
send get-next requests until it reaches a different part of the tree
or the next OID is smaller than the previous one (it's looping).

At startup the target configuration file (-t option) is parsed and a
linked list of hosts is created. For each host, another linked list of
targets is built. When polling, each thread takes a single host from
the list and goes through its targets in order. This means that a
single host will never be polled by two threads simultaneously which
could cause it to become overloaded. 

Each result of a get-next request is stored in memory along with a
timestamp so that the delta and rate of change can be calculated
between rounds. Since get-nexts return the results in order (in
well-behaved snmp agents) they can be stored in an efficient linked
list. Rated can detect when new OIDS need to be inserted or deleted
from the list but in the common case where the agent returns the same
OIDS in the same order it can walk through the list (so it just
updates a pointer every time instead of searching).

For counters, after the second successfull poll, the delta between the
current value of the counter and the previous value is calculated as
well as the rate of change (ie difference divided by the time between
polls). These values are then sent to the database driver.  It does
database inserts synchronously for each OID as a means of throttling
the frequency of SNMP requests being sent to the target host.

Rated will detect and correct counter wraps, when the (32 bit) counter
has overflowed and the new value is less than the previous value. This
can also occur when the device is rebooted but that condition isn't
handled separately (yet). You can avoid wrapping by using 64 bit
counters when available.

If there is a problem inserting into the database, rated will keep the
last value and timestamp the same. When the database comes back, it
will do a single insert with the delta and rate since then. So it
loses precision but should maintain the correct value. Otherwise
trying to cache all of the intermediate values can quickly use up the
available memory and flood the database with inserts when it reconnects.

Here's a sample rated.conf file:

Interval    30
DB_Host     localhost
DB_Database rtg
DB_User     rtg
DB_Pass     rtg
DB_Driver   libratedpgsql.so
Threads     5

Here's a sample target configuration file:

host 192.168.1.2 {
    community public;
    snmpver 2;
    # ifHCInOctets
    target .1.3.6.1.2.1.31.1.1.1.6 {
        table ifinoctets;
    }
    # ifHCOutOctets
    target .1.3.6.1.2.1.31.1.1.1.10 {
        table ifoutoctets;
    }
    # ifHCInUcastPkts
    target .1.3.6.1.2.1.31.1.1.1.7 {
        table ifinucastpkts;
    }
    # ifHCOutUcastPkts
    target .1.3.6.1.2.1.31.1.1.1.11 {
        table ifoutucastpkts;
    }
}

